// Generated by CoffeeScript 2.6.1
(function() {
  //Points and Paths - alpha

  //ok, starting point? MnSp?
  //	pull over: lots of misc PM stuff, board locking(from MnSp)
  //	new(?): clicks, thin-accelerate, img load

  //I guess the 1st todo is getting sprites to sit (vs die at end of path)
  //	maybe we make groups static?

  //gotta lock to board after thin
  //--

  //$ ->
  //  myGame = new Game
  //  myGame.run()
  //PE = require("poker-evaluator")
  var Board, Game, Sprite;

  Game = (function() {
    class Game {
      constructor() {
        var e, frac, host, i, i1, j, j1, k1, l1, len, len1, len2, len3, o, r, ref, ref1, ref2, ref3, ref4, s, startTh, th, u, v, w, y, z;
        //	addB: (B, Q, s) ->
        //rmB: () ->

        //-----||-----||-----
        this.main = this.main.bind(this);
        this.onMouseDown = this.onMouseDown.bind(this);
        //do we have a set() for the board yet??  **must be able to interact seemlessly
        this.onMouseMove = this.onMouseMove.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onKeyDown = this.onKeyDown.bind(this);
        //----Sprite Creation Routines-----
        //external behavior to insert into sprite queu
        this.mkBehavior = this.mkBehavior.bind(this);
        host = "http://localhost:3000";
        //		host = "http://frozen-gorge-8975.herokuapp.com"  #is this the problem?? imgs not serving??
        this.dev = true;
        //load images
        this.cardsImg = new Image();
        this.cardsImg.src = host + "/../images/cards4.png";
        this.canvas = document.getElementById('canvas');
        this.ctx = canvas.getContext("2d");
        HTMLCanvasElement.prototype.relMouseCoords = this.relMouseCoords; //??
        this.x = 0;
        this.y = 0;
        this.hand = [];
        this.handPts = []; //?
        this.timer = 7200; //consider using only the first 90 frames
        this.score = 0;
        this.scoreBank = [];
        this.timerBank = [];
        this.cardBG = new Image();
        this.cardBG.src = host + "/../images/cardBG.png";
        for (i = o = 0; o <= 3; i = ++o) {
          this.loadImg = new Image();
          this.loadImg.src = host + `/../images/scoreImageBank${i}a.png`;
          this.scoreBank.push(this.loadImg);
          this.loadImg = new Image();
          this.loadImg.src = host + `/../images/clockImageBank${i}a.png`;
          this.timerBank.push(this.loadImg);
        }
        this.tFrameNum = 0; //0-119; (timer/120).toInt?
        this.scFrameNum = 0; //0-119; using 0-89 at present
        
        //["bridge_charged","bridge_charged_hover","joker_charged","joker_charged_hover","rotate_charged","rotate_charged_hover","shuffle_charged","shuffle_charged_hover","suits_charged","suits_charged_hover"] #,"bomb_charged","bomb_charged_hover"]
        this.boardTiles = [
          "break",
          "shuffle",
          "joker",
          "rotate",
          "reroll",
          "bridge" //,"PokerMGraphics/CardBack1"]
        ];
        this.powerImgs = (function() {
          var ref, results, u;
          results = [];
          for (i = u = 0, ref = this.boardTiles.length - 1; (0 <= ref ? u <= ref : u >= ref); i = 0 <= ref ? ++u : --u) {
            results.push(new Image());
          }
          return results;
        }).call(this);
        ref = this.boardTiles;
        //ImgScroll/
        for (i = u = 0, len = ref.length; u < len; i = ++u) {
          e = ref[i];
          this.powerImgs[i].src = `http://localhost:3000/../images/${e}.png`;
        }
        //		@powerImgs[i].src = "http://frozen-gorge-8975.herokuapp.com/../images/#{e}.png" for e,i in @boardTiles  #ImgScroll/
        this.powerNotes = ["Break", "Shuffle", "Joker", "Rotate", "ReRoll", "Bridge"];
        this.powerLoc = (function() {
          var results, v;
//[[600,150],[600,200],[600,250],[600,300],[600,350],[600,400]]
          results = [];
          for (y = v = 250; v <= 500; y = v += 50) {
            results.push([625, y]);
          }
          return results;
        })();
        this.bank = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3];
        this.bankFrameX = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5];
        this.bankFrameY = [0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4];
        this.boards = [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0], [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0], [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0], [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0], [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0], [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0], [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0], [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]], [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]], [[0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0], [0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0], [0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], [0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], [0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0]], [[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]], [[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1], [1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0], [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1], [0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], [1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0]], [[1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1], [0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0], [0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0], [1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0], [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0], [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1], [0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1], [1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0]], [[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]], [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1], [1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1], [1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1], [1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1], [1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1], [1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1], [1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1], [1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1], [1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], [[1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1], [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]], [[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0], [1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]], [[1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0], [1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0], [1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], [1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1], [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1], [1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0], [0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1], [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1], [1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0], [0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1], [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1], [1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0], [0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1], [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]], [[0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]], [[1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1], [1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1], [0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1], [1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0], [1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1], [1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0], [1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1]], [[1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1], [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1], [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1], [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1], [1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1]], [[1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1], [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1], [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1], [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1], [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1]], [[1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1], [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1], [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1], [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1], [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1], [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1], [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0], [1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1], [0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0]], [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1], [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1], [1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1]], [[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1], [1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1], [0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0], [1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1], [1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]], [[1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1], [1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0], [0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0], [0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0], [0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0], [0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1], [1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], [[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]];
        //		@boardNames = []
        this.boardOrder = [0, 27, 13, 15, 29, 12, 11, 28, 10, 20, 2, 1, 8, 4, 30, 25, 24, 22, 18, 19, 17, 16, 5, 23, 7, 3, 6, 21, 26, 14, 9];
        //		@curOrder = 0
        //		@plus = true #use mouseHit() instead of mouseDown()??
        //@level = 0 #@curOrder??
        //		@curBoard = (e.slice(0) for e in @boards[0])
        //		@backBoard = (e.slice(0) for e in @boards[0]) #for animations
        //		@markBoard = (e.slice(0) for e in @boards[0])
        this.rotPos = (function() {
          var len1, ref1, results, v;
          ref1 = this.boards[0];
          results = [];
          for (v = 0, len1 = ref1.length; v < len1; v++) {
            e = ref1[v];
            results.push(e.slice(0));
          }
          return results;
        }).call(this);
        this.rotBackBoard = (function() {
          var len1, ref1, results, v;
          ref1 = this.boards[0];
          results = [];
          for (v = 0, len1 = ref1.length; v < len1; v++) {
            e = ref1[v];
            results.push(e.slice(0));
          }
          return results;
        }).call(this);
        this.shufflePos = (function() {
          var len1, ref1, results, v;
          ref1 = this.boards[0];
          results = [];
          for (v = 0, len1 = ref1.length; v < len1; v++) {
            e = ref1[v];
            results.push(e.slice(0));
          }
          return results;
        }).call(this);
        this.shuffleBackBoard = (function() {
          var len1, ref1, results, v;
          ref1 = this.boards[0];
          results = [];
          for (v = 0, len1 = ref1.length; v < len1; v++) {
            e = ref1[v];
            results.push(e.slice(0));
          }
          return results;
        }).call(this);
        this.stack = [];
        this.shuffleList = [];
        this.boardLock = false;
        this.lastPos = [];
        this.firstPos = [];
        this.canvas = document.getElementById('canvas');
        this.ctx = canvas.getContext("2d");
        this.ctx.font = "24px Arial";
        HTMLCanvasElement.prototype.relMouseCoords = this.relMouseCoords; //??
        
        //relative mouse coords support #are we using this now??
        this.stylePaddingLeft = parseInt(document.defaultView.getComputedStyle(canvas, null)['paddingLeft'], 10) || 0;
        this.stylePaddingTop = parseInt(document.defaultView.getComputedStyle(canvas, null)['paddingTop'], 10) || 0;
        this.styleBorderLeft = parseInt(document.defaultView.getComputedStyle(canvas, null)['borderLeftWidth'], 10) || 0;
        this.styleBorderTop = parseInt(document.defaultView.getComputedStyle(canvas, null)['borderTopWidth'], 10) || 0;
        // Some pages have fixed-position bars (like the stumbleupon bar) at the top or left of the page
        // They will mess up mouse coordinates and this fixes that
        this.canvasMinX = $("#canvas").offset().left;
        this.canvasMinY = $("#canvas").offset().top;
        //call these once?
        $(document).mousedown(this.onMouseDown);
        $(document).mouseup(this.onMouseUp);
        $(document).mousemove(this.onMouseMove);
        $(document).keydown(this.onKeyDown);
        this.sprList = [];
        this.power = 0;
        this.breaks = 100;
        this.shuffles = 100;
        this.jokers = 100;
        this.rotates = 100;
        this.rerolls = 100;
        this.bridges = 100;
        //used?
        this.breaksX = 600;
        this.shufflesX = 600;
        this.jokersX = 600;
        this.rotatesX = 600;
        this.rerollsX = 600;
        this.bridgesX = 600;
        this.breaksY = 150;
        this.shufflesY = 200;
        this.jokersY = 250;
        this.rotatesY = 300;
        this.rerollsY = 350;
        this.bridgesY = 400;
        this.activeup = -1;
//----------
//i1/j1 calcs? 220, 260; [220-(6-i)*40,220-(6-j)*40]; [220-(6-i)*40,260+(j-7)*40]; [260+(i-7)*40,220-(6-j)*40];[260+(i-7)*40,260+(j-7)*40]
        for (i = v = 0; v <= 13; i = ++v) {
          for (j = w = 0; w <= 13; j = ++w) {
            if (i < 7) { //these are all offset by 20 (to center the cards)
              i1 = -20 - (6 - i) * 40;
            }
            if (j < 7) {
              j1 = -20 - (6 - j) * 40;
            }
            if (i > 6) {
              i1 = 20 + (i - 7) * 40;
            }
            if (j > 6) {
              j1 = 20 + (j - 7) * 40;
            }
            frac = Math.PI / 60.0;
            r = Math.sqrt(i1 * i1 + j1 * j1);
            startTh = Math.atan2(i1, j1);
            //[i][j][index][x], [index][y]
            this.rotPos[i][j] = (function() {
              var results, z;
              results = [];
              for (th = z = 0; z <= 29; th = ++z) {
                results.push([Math.round(r * Math.sin(startTh - th * frac)) + 20, Math.round(r * Math.cos(startTh - th * frac)) + 20]);
              }
              return results;
            })();
          }
        }
        this.rotBoardIndex = 0; //serves entire board
        this.rotBoard = false;
        this.shuffleIndex = 0;
        this.shuffleBoard = false;
        this.select = [];
        setInterval(this.main, 60); //was 200?
        //		setInterval(@cleanSprites,2)
        this.spriteQ = [[]];
        this.spriteB = [[]];
        this.effectQ = [[]];
        this.upQ = [[]];
        this.upsB = new Board(610, 290, 1, 6, 40, 40);
        this.ups = (function() {
          var len1, ref1, results, z;
          ref1 = this.upsB.luta;
          results = [];
          for (z = 0, len1 = ref1.length; z < len1; z++) {
            e = ref1[z];
            results.push(new Sprite(this.powerImgs, [this.sprPos(this.upsB, e[0], e[1])]));
          }
          return results;
        }).call(this);
        ref1 = this.ups;
        for (z = 0, len1 = ref1.length; z < len1; z++) {
          s = ref1[z];
          this.ups[this.bPos1(this.upsB, s.pos[0], s.pos[1])] = s;
        }
        ref2 = this.ups;
        for (e in ref2) {
          i = ref2[e];
          e.id = i;
        }
        this.upQ.unshift(this.ups);
        $('#out').text(JSON.stringify([this.ups.length, this.upQ[0].length, this.upsB.luta]));
        this.B = new Board(50, 50, 14, 14, 40, 40); //**are we not using these at present??
        this.B.setmask(this.boards[0]);
        this.cardsSrcIndex = (function() {
          var k1, results;
//only works if sheet is drawn "right"
          results = [];
          for (i = k1 = 0; k1 <= 51; i = ++k1) {
            results.push([i % 4 * 40, i % 13 * 40]);
          }
          return results;
        })();
        this.sprites = (function() {
          var k1, len2, ref3, results;
          ref3 = this.B.maska;
          results = [];
          for (k1 = 0, len2 = ref3.length; k1 < len2; k1++) {
            e = ref3[k1];
            results.push(new Sprite(this.cardsImg, [this.sprPos(this.B, e[0], e[1])]));
          }
          return results;
        }).call(this);
        ref3 = this.sprites;
        //is this working??
        for (k1 = 0, len2 = ref3.length; k1 < len2; k1++) {
          s = ref3[k1];
          this.sprites[this.bPos1(this.B, s.pos[0], s.pos[1])] = s;
        }
        this.spriteQ.unshift(this.sprites);
        ref4 = this.spriteQ[0];
        for (l1 = 0, len3 = ref4.length; l1 < len3; l1++) {
          e = ref4[l1];
          e.id = this.xRand(52);
        }
        
        //		$('#out').text(JSON.stringify([(e? for e in @columns(@B,@spriteQ[0])[5] when e?)]))   #WTF, why is this different than the same thing below?? !! ??

        //		@ups = new board(50,50,16,16,40,40)
        this.mmLock = false;
        this.mdLock = false;
        //		window.onload = =>

        //		$('#out').text(JSON.stringify([@spriteQ[0].length]))
        this.cnt = 0;
      }

      //	fillBoard: (B,sprB) -> sprB.push(new Sprite(@cardsImgs, [p[0],p[1]], {id: @xRand(52)})) for p in B.mask  #flexible construct using map??

        //----------
      //Knuth shuffle
      knuth(l) {
        var i, j, results;
        i = l.length;
        if (i === 0) {
          return false;
        }
        results = [];
        while (--i) {
          j = Math.floor(Math.random() * (i + 1));
          results.push([l[i], l[j]] = [l[j], l[i]]);
        }
        return results;
      }

      mkShufflePaths() {
        var a, b, c, len, len1, o, ref, results, row, u, x, y;
        this.shuffleList = [];
        ref = this.curBoard;
        for (x = o = 0, len = ref.length; o < len; x = ++o) {
          row = ref[x];
          for (y = u = 0, len1 = row.length; u < len1; y = ++u) {
            c = row[y];
            if (c !== 0) {
              this.shuffleList.push([x, y]);
            }
          }
        }
        knuth(this.shufflelist);
        results = [];
        //knuth
        //		i = @shuffleList.length
        //		#return false if i is 0
        //		while --i
        //		    j = Math.floor(Math.random() * (i+1))
        //		    [@shuffleList[i], @shuffleList[j]] = [@shuffleList[j], @shuffleList[i]]
        while (this.shuffleList.length > 1) {
          a = this.shuffleList.pop();
          b = this.shuffleList.pop();
          [this.curBoard[a[0]][a[1]], this.curBoard[b[0]][b[1]]] = [this.curBoard[b[0]][b[1]], this.curBoard[a[0]][a[1]]];
          //**Gotta change from board coords to screen coords (before rounding)
          c = [(a[0] + b[0]) / 2, Math.abs(a[1] - b[1]) + 2];
          this.shufflePos[b[0]][b[1]] = this.benzier(a, b, c, 30);
          results.push(this.shufflePos[a[0]][a[1]] = this.shufflePos[b[0]][b[1]].slice(0).reverse()); //benzier() #shufflePos[a[0],a[1]].reverse
        }
        return results;
      }

      //		$('#out').text(JSON.stringify([@shufflePos[a[0]][b[1]]]))

        //----- usefull fns -----
      mapentries(m) {
        var e, k, results;
        results = [];
        for (k in m) {
          e = m[k];
          results.push(e);
        }
        return results;
      }

      add(a, b) {
        return a + b;
      }

      concatFn(a, b) {
        return a.concat(b);
      }

      xRand(e) {
        return Math.floor(Math.random() * e);
      }

      vRand(e) {
        var i;
        i = this.xRand(e.length);
        return e[i];
      }

      flipIJ(a) {
        return [a[1], a[0]];
      }

      flattenOne(arr) {
        return arr.reduce(this.concatFn, []);
      }

      knuth(a) {
        var n, r;
        n = a.length;
        while (n > 1) {
          r = this.xRand(n);
          n -= 1;
          [a[n], a[r]] = [a[r], a[n]];
        }
        return a;
      }

      lockinput() {
        $(document).off('mousedown', this.onMouseDown);
        $(document).off('mouseup', this.onMouseUp);
        $(document).off('mousemove', this.onMouseMove);
        return $(document).off('keydown', this.onKeyDown);
      }

      unlockinput() {
        $(document).on('mousedown', this.onMouseDown);
        $(document).on('mouseup', this.onMouseUp);
        $(document).on('mousemove', this.onMouseMove);
        return $(document).on('keydown', this.onKeyDown);
      }

      main() {
        this.ctx.clearRect(0, 0, 800, 600);
        this.processSpriteQ(this.spriteQ);
        this.processSpriteQ(this.effectQ);
        this.processSpriteQ(this.upQ);
        //@rendTime()  #how are we handling timer??
        this.renderCards(this.spriteQ);
        this.renderQ(this.upQ);
        if (this.timer > 0) {
          this.timer -= 1;
        }
        //gameOver() if @timer < 1 and @curBoard is 25
        this.tFrameNum = parseInt((7200 - this.timer) / 60);
        this.cnt++;
        //		$('#out').text(JSON.stringify([[@x,@y], @activeup, @spriteQ[0].length]))
        return $('#out').text(JSON.stringify([PE.evalHand("As", "Ks", "Qs", "Js", "Ts", "3c", "5h")]));
      }

      //	cleanSprites(sprList): => sprList = (spr for spr in sprList when spr.kill)

        //so, we're assuming spriteQ...
      processSpriteQ(q) {
        var len, o, ref, ref1, results, s;
        if (q[0].length === 0 && (q[1] != null)) {
          q.shift();
        }
        ref = q[0];
        //		q[0] = (s for s in q[0] when s.kill isnt true)  #this is fucking things up, maybe that's why we were cleaning less often??
        results = [];
        for (o = 0, len = ref.length; o < len; o++) {
          s = ref[o];
          s.pos = (ref1 = s.path.shift()) != null ? ref1 : s.pos;
          //			s.kill = true if s.path.length is 0  #defaults to sitting now? otherwise sets kill for cleanup? when/where?
          s.v = [s.v[0] + s.a[0], s.v[1] + s.a[1]];
          s.pos = [s.pos[0] + s.v[0], s.pos[1] + s.v[1]];
          //			@ctx.drawImage(s.img,s.pos[0],s.pos[1]) if s.img?  #time cost vs utility of behavior sprites??
          results.push(s.update());
        }
        return results;
      }

      //(collisions and clicks)
      renderQ(Q) {
        var i, ref, results, s;
        ref = Q[0];
        results = [];
        for (i in ref) {
          s = ref[i];
          if (s.img[i] != null) {
            //		$('#out').text(JSON.stringify(["renderQ",Q[0].length,Q[0][0].img[0]?,([i,s.img[i]?] for i,s of Q[0] when s.img[i]?)]))  #what jank
            results.push(this.ctx.drawImage(s.img[i], s.pos[0], s.pos[1]));
          }
        }
        return results;
      }

      renderCards(Q) { //accept board?
        var e, len, len1, o, ref, ref1, s, u, x, xy, y;
        this.ctx.globalAlpha = 1;
        ref = Q[0];
        for (o = 0, len = ref.length; o < len; o++) {
          s = ref[o];
          xy = this.cardsSrcIndex[[s.id]];
          if (!this.select[this.bPos(this.B, s.pos[0], s.pos[1])]) {
            this.ctx.drawImage(s.img, xy[0], xy[1], 40, 40, s.pos[0], s.pos[1], 40, 40);
          }
        }
        this.ctx.globalAlpha = 0.5;
        this.ctx.fillStyle = "#000000";
        ref1 = this.select;
        for (u = 0, len1 = ref1.length; u < len1; u++) {
          e = ref1[u];
          [x, y] = this.sprPos(this.B, e[0], e[1]);
          this.ctx.fillRect(x, y, 40, 40);
        }
        this.ctx.globalAlpha = 1;
        this.ctx.drawImage(this.scoreBank[this.bank[this.scFrameNum]], this.bankFrameX[this.scFrameNum] * 108, this.bankFrameY[this.scFrameNum] * 108, 108, 108, 600, 100, 108, 108);
        return this.ctx.drawImage(this.timerBank[this.bank[this.tFrameNum]], this.bankFrameX[this.tFrameNum] * 108, this.bankFrameY[this.tFrameNum] * 108, 108, 108, 600, 100, 108, 108);
      }

      //---------------
      eval(h) {
        var c, cardsInHand, cih, e, flush, handScore, i, j, jokers, js, k1, len, len1, len2, len3, o, pairs, permStraightCount, quads, quints, ranks, score, set, straightCount, suits, suitsInHand, type, u, v, w, z;
        //		$('#out').text(JSON.stringify([@hand,h]))
        type = [null, "no pair", null, null, null, "pair", null, null, "two pair", "set", "straight", "flush", "full house", "quads", "straight flush", null, null, "quints"];
        score = [
          null,
          0,
          null,
          null,
          null,
          1,
          null,
          null,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          null,
          null,
          9 //mkFlush=Straight?
        ];
        jokers = 0;
        for (o = 0, len = h.length; o < len; o++) {
          i = h[o];
          if (i === 53) {
            jokers += 1;
          }
        }
        h = (function() {
          var len1, results, u;
          results = [];
          for (u = 0, len1 = h.length; u < len1; u++) {
            e = h[u];
            if (e !== 53) {
              results.push(e);
            }
          }
          return results;
        })();
        suits = (function() {
          var len1, results, u;
          results = [];
          for (u = 0, len1 = h.length; u < len1; u++) {
            c = h[u];
            results.push(c % 4);
          }
          return results;
        })();
        ranks = (function() {
          var len1, results, u;
          results = [];
          for (u = 0, len1 = h.length; u < len1; u++) {
            c = h[u];
            results.push(c % 13);
          }
          return results;
        })();
        cardsInHand = (function() {
          var results, u;
          results = [];
          for (i = u = 0; u <= 13; i = ++u) {
            results.push(0);
          }
          return results;
        })();
        for (u = 0, len1 = h.length; u < len1; u++) {
          e = h[u];
          cardsInHand[e % 13] += 1;
        }
        suitsInHand = (function() {
          var results, v;
          results = [];
          for (i = v = 0; v <= 3; i = ++v) {
            results.push(0);
          }
          return results;
        })();
        for (v = 0, len2 = h.length; v < len2; v++) {
          e = h[v];
          suitsInHand[e % 4] += 1;
        }
        flush = false;
        for (i = w = 0; w <= 3; i = ++w) {
          suitsInHand[i] += jokers;
        }
        for (z = 0, len3 = suitsInHand.length; z < len3; z++) {
          i = suitsInHand[z];
          if (i === 5) {
            flush = true;
          }
        }
        cardsInHand[13] = cardsInHand[0];
        pairs = 0;
        set = false;
        quads = false;
        quints = false;
//13?
        for (i = k1 = 0; k1 <= 12; i = ++k1) {
          cih = cardsInHand[i];
          if (cih >= 2) {
            pairs = pairs + 1;
          }
          if (cih >= 3) {
            set = true;
          }
          if (cih >= 4) {
            quads = true;
          }
          if (cih === 5) {
            quints = true;
          }
          js = jokers;
          straightCount = 1; //+ js
          if (cih === 1 && i < 10) {
            j = 1;
            while (cardsInHand[i + j] === 1 || js !== 0) {
              if (cardsInHand[i + j] === 1 || js > 0) {
                straightCount += 1;
              }
              if (cardsInHand[i + j] === 0) {
                js -= 1;
              }
              j += 1;
            }
            if (straightCount === 5) {
              permStraightCount = true;
            }
          }
        }
        handScore = 1;
        if (pairs === 1) {
          handScore = 5;
        }
        if (pairs === 2) {
          handScore = 8;
        }
        if (set) {
          handScore = 9;
        }
        if (permStraightCount) {
          handScore = 10;
        }
        if (flush) {
          handScore = 11;
        }
        if (set && pairs === 2) {
          handScore = 12;
        }
        if (quads) {
          handScore = 13;
        }
        if (flush && permStraightCount) { //is 5
          handScore = 14;
        }
        if (quints) {
          handScore = 17;
        }
        while ((jokers > 0) && ((handScore === 1) || (handScore === 9) || (handScore === 13) || (handScore === 8))) {
          handScore += 4;
          jokers -= 1;
        }
        //		$('#out').text(JSON.stringify([type[handScore]]))
        return score[handScore];
      }

      //-----**Mouse Events**-----
      compPts(p, p1) {
        return p[0] === p1[0] && p[1] === p1[1];
      }

      onMouseDown(e) {
        var ref, ref1, s, x1, xr, y1, yr;
        //[@x,@y] = canvas.relMouseCoords(e)
        [xr, yr] = this.getPosition(e);
        [this.x, this.y] = this.bPos(this.B, xr, yr);
        //		$('#out').text(JSON.stringify([[@x,@y], @activeup]))
        [x1, y1] = this.bPos(this.upsB, xr, yr);
        //		$('#out').text(JSON.stringify([[x1,y1]]))
        if ((-1 < (ref = this.x) && ref < 14) && (-1 < (ref1 = this.y) && ref1 < 14)) { //@B.bWidth		#(@x isnt -1) and (@y isnt -1)
          switch (this.activeup) {
            case 0:
              //if not @spriteQ[0][@x,@y]   #**right, huh, we have to add it to the B.maska too ??
              if (this.spriteQ[0][[this.x, this.y]] !== 1) { //and @x @y
                s = new Sprite(this.cardsImg, [this.sprPos(this.B, this.x, this.y)]); //**gotta change forth and back to lock ??**
                s.id = this.xRand(52);
                this.spriteQ[0].push(s);
                this.spriteQ[0][[this.x, this.y]] = s; //true
                this.B.maska.push([
                  this.x,
                  this.y //**hmm... bridged tiles still not dropping quite right**
                ]);
                this.B.maska[[this.x, this.y]] = true;
              }
              break;
            //						@sprites = (new Sprite(@cardsImg,[@sprPos(@B,e[0],e[1])]) for e in @B.maska)
            //						@sprites[@bPos1(@B,s.pos[0],s.pos[1])] = s for s in @sprites #is this working??
            //						@spriteQ.unshift(@sprites)
            //						e.id = @xRand(52) for e in @spriteQ[0] #??
            case 1:
              this.activeup = -1; //filler
              break;
            default:
              this.mdLock = true;
              this.select = [[this.x, this.y]];
              this.select[[this.x, this.y]] = true;
          }
        }
        //					$('#out').text(JSON.stringify(["true",@select]))

        //["bridge_charged","bridge_charged_hover","joker_charged","joker_charged_hover","rotate_charged","rotate_charged_hover","shuffle_charged","shuffle_charged_hover","suits_charged","suits_charged_hover"] #,"bomb_charged","bomb_charged_hover"]
        //activate here, and check... above?
        if (x1 === 0) {
          switch (y1) {
            case 0: //bridge
              if (this.activeup !== 0) {
                return this.activeup = 0;
              } else {
                return this.activeup = -1;
              }
              break;
            case 1: //joker
              return this.activeup = 1;
          }
        }
      }

      onMouseMove(e) {
        var hand, s, xr, yr;
        //		$('#out').text(JSON.stringify([@select]))
        hand = (function() {
          var len, o, ref, results;
          ref = this.select;
          results = [];
          for (o = 0, len = ref.length; o < len; o++) {
            s = ref[o];
            results.push(this.spriteQ[0][s].id);
          }
          return results;
        }).call(this);
        //		$('#out').text(JSON.stringify([@select,hand,@eval(hand),@activeup]))  #,@printQ(@spriteQ[0])
        if (this.mdLock) {
          [xr, yr] = this.getPosition(e);
          [this.x, this.y] = this.bPos(this.B, xr, yr);
          if ((this.x !== -1) && (this.y !== -1) && (this.spriteQ[0][[this.x, this.y]] != null)) {
            if ((this.select[[this.x, this.y]] == null) && this.select.length < 5 && Math.abs(this.x - this.select[this.select.length - 1][0]) < 2 && Math.abs(this.y - this.select[this.select.length - 1][1]) < 2) {
              this.select.push([this.x, this.y]);
              this.select[[this.x, this.y]] = true;
            }
            if (this.select.length > 1 && this.compPts(this.select[this.select.length - 2], [this.x, this.y])) {
              e = this.select.pop();
              return delete this.select[e];
            }
          }
        }
      }

      onMouseUp(e) {
        var c, cnt, go, hand, k, len, len1, longpath, o, ref, ref1, ref2, s, spr, u;
        //		$('#out').text(JSON.stringify([@select]))
        hand = (function() {
          var len, o, ref, results;
          ref = this.select;
          results = [];
          for (o = 0, len = ref.length; o < len; o++) {
            s = ref[o];
            results.push(this.spriteQ[0][s].id);
          }
          return results;
        }).call(this);
        //		$('#out').text(JSON.stringify([@select,hand,@eval(hand)]))  #,@printQ(@spriteQ[0])
        if (this.select.length > 1) {
          this.lockinput();
          ref = this.select;
          for (o = 0, len = ref.length; o < len; o++) {
            s = ref[o];
            delete this.spriteQ[0][s];
          }
          while (this.spriteQ[0][0] != null) {
            this.spriteQ[0].pop();
          }
          ref1 = this.spriteQ[0];
          for (k in ref1) {
            e = ref1[k];
            this.spriteQ[0].push(e);
          }
          this.scFrameNum += this.eval(hand);
          longpath = 0;
          ref2 = this.columns(this.B, this.spriteQ[0]);
          for (u = 0, len1 = ref2.length; u < len1; u++) {
            c = ref2[u];
            go = false;
            cnt = 0;
            while (c.length > 0) {
              spr = c.pop();
              if (go && (spr == null)) {
                cnt++;
              }
              if (spr != null) {
                if (!go) {
                  go = true;
                }
                if (go && cnt > 0) {
                  spr.path = this.thin(this.bline(spr.pos, [spr.pos[0], spr.pos[1] + cnt * this.B.tHeight]), 8);
                }
                if (cnt > longpath) {
                  longpath = cnt;
                }
              }
            }
          }
          s = this.mkBehavior(() => {
            var len2, ref3, results, v;
            this.locktoB(this.B, this.spriteQ[0]);
            this.unlockinput();
            ref3 = this.B.maska;
            results = [];
            for (v = 0, len2 = ref3.length; v < len2; v++) {
              e = ref3[v];
              if (this.spriteQ[0][e] == null) {
                s = new Sprite(this.cardsImg, [this.sprPos(this.B, e[0], e[1])]);
                s.id = this.xRand(52);
                this.spriteQ[0][e] = s;
                results.push(this.spriteQ[0].push(s));
              } else {
                results.push(void 0);
              }
            }
            return results;
          });
          //add some sort of fade in
          s.update = function() {
            this.delay++;
            if (this.delay > longpath * 5) { //why don't we need a closure here
              return this.pkux();
            }
          };
          this.effectQ.unshift([s]);
        }
        this.mdLock = false;
        return this.select = [];
      }

      onKeyDown(e) {}

      //the miki725 solution
      getPosition(e) {
        var targ, x, y;
        if (!e) {
          e = window.event;
        }
        if (e.target) {
          targ = e.target;
        } else if (e.srcElement) {
          targ = srcElement;
        }
        if (targ.nodeType === 3) { //for safari bug; still needed?
          targ = targ.parentNode;
        }
        x = e.pageX - $(targ).offset().left;
        y = e.pageY - $(targ).offset().top;
        return [x, y];
      }

      //-----Path Creation Tools-----
      zeroPath(start, rep) {
        var i, o, ref, results;
        results = [];
        for (i = o = 0, ref = rep; (0 <= ref ? o <= ref : o >= ref); i = 0 <= ref ? ++o : --o) {
          results.push(start);
        }
        return results;
      }

      line(p0, p1, nSeg) {
        return false;
      }

      bline(pnt1, pnt2) { //bresenham's
        var dx, dy, e2, err, p1, p2, path, sx, sy;
        p1 = pnt1.slice(0);
        p2 = pnt2.slice(0);
        dx = Math.abs(p2[0] - p1[0]);
        dy = Math.abs(p2[1] - p1[1]);
        sx = p1[0] < p2[0] ? 1 : -1;
        if (p1[0] === p2[0]) {
          sx = 0;
        }
        sy = p1[1] < p2[1] ? 1 : -1;
        if (p1[1] === p2[1]) {
          sy = 0;
        }
        err = (dx > dy ? dx : dy) / 2;
        path = [];
        while (true) {
          path.push([p1[0], p1[1]]);
          if ((p1[0] === p2[0]) && (p1[1] === p2[1])) {
            break;
          }
          e2 = err;
          if (e2 > -dx) {
            err -= dy;
            p1[0] += sx;
          }
          if (e2 < dy) {
            err += dx;
            p1[1] += sy;
          }
        }
        return path;
      }

      benzier(p1, p2, p3, nSeg) {
        var a, b, c, i, o, path, ref, t, t1;
        path = [];
        for (i = o = 0, ref = nSeg; (0 <= ref ? o <= ref : o >= ref); i = 0 <= ref ? ++o : --o) {
          t = i / nSeg;
          t1 = 1.0 - t;
          a = Math.pow(t1, 2);
          b = 2.0 * t * t1;
          c = Math.pow(t, 2);
          path.push([Math.round((a * p1[0] + b * p2[0] + c * p3[0]) * 40), Math.round((a * p1[1] + b * p2[1] + c * p3[1]) * 40)]);
        }
        return path;
      }

      circle(p1, r, nSeg) {
        var angle, o, ref, ref1, results;
        results = [];
        for (angle = o = 0, ref = 2 * Math.PI, ref1 = 2 * Math.PI / (nSeg - 1); ref1 !== 0 && (ref1 > 0 ? o <= ref : o >= ref); angle = o += ref1) {
          results.push([Math.floor(r * Math.cos(angle) + p1[0]), Math.floor(r * Math.sin(angle) + p1[1])]);
        }
        return results;
      }

      //bcircle: (p1,r) -> false
      thin(path, rate) {
        var i, len, o, ref, results;
        ref = rate;
        //first pass on thin
        results = [];
        for ((ref > 0 ? (o = 0, len = path.length) : o = path.length - 1); ref > 0 ? o < len : o >= 0; o += ref) {
          i = path[o];
          results.push(i);
        }
        return results;
      }

      drawPath(path) {
        var i, j, len, o, results;
        this.ctx.moveTo(path[0][0], path[0][1]);
        results = [];
        for (o = 0, len = path.length; o < len; o++) {
          [i, j] = path[o];
          this.ctx.lineTo(i, j);
          results.push(this.ctx.stroke());
        }
        return results;
      }

      rotatePathR(path, count) {
        var i, o, ref, results;
        results = [];
        for (i = o = 0, ref = count; (0 <= ref ? o <= ref : o >= ref); i = 0 <= ref ? ++o : --o) {
          results.push(path.shift(path.pop()));
        }
        return results;
      }

      rotatePathL(path, count) {
        var i, o, ref, results;
        results = [];
        for (i = o = 0, ref = count; (0 <= ref ? o <= ref : o >= ref); i = 0 <= ref ? ++o : --o) {
          results.push(path.push(path.unshift()));
        }
        return results;
      }

      //pntsInCircle/square/rect... rndPntsIn... drawConnectedPath, guassianThin/rndGuassianThin, sinPath
      //smoothPath - keeps distance from one pnt to next within some error
      //accelerate

        //----Board Manipulation Routines-----
      //adjustments for hex boards??
      row(B, spriteB, j) {
        var i, o, ref, results;
        results = [];
        for (i = o = 0, ref = B.bWidth; (0 <= ref ? o <= ref : o >= ref); i = 0 <= ref ? ++o : --o) {
          if (B.maska[[i, j]] != null) {
            results.push(spriteB[[i, j]]);
          }
        }
        return results;
      }

      row1(B, spriteB, j) {
        var i, o, ref, results;
        results = [];
        for (i = o = 0, ref = B.bWidth; (0 <= ref ? o <= ref : o >= ref); i = 0 <= ref ? ++o : --o) {
          results.push(spriteB[[i, j]]);
        }
        return results;
      }

      rows(B, spriteB) {
        var j, o, ref, results;
        results = [];
        for (j = o = 0, ref = B.bHeight; (0 <= ref ? o <= ref : o >= ref); j = 0 <= ref ? ++o : --o) {
          results.push(row1(B, spriteB, j));
        }
        return results;
      }

      column(B, spriteB, i) {
        var j, o, ref, results;
        results = [];
        for (j = o = 0, ref = B.bHeight; (0 <= ref ? o <= ref : o >= ref); j = 0 <= ref ? ++o : --o) {
          if (B.maska[[i, j]]) {
            results.push(spriteB[[i, j]]);
          }
        }
        return results;
      }

      column1(B, spriteB, i) {
        var j, o, ref, results;
        results = [];
        for (j = o = 0, ref = B.bHeight - 1; (0 <= ref ? o <= ref : o >= ref); j = 0 <= ref ? ++o : --o) {
          results.push(spriteB[[i, j]]);
        }
        return results;
      }

      columns(B, spriteB) {
        var i, o, ref, results;
        results = [];
        for (i = o = 0, ref = B.bWidth - 1; (0 <= ref ? o <= ref : o >= ref); i = 0 <= ref ? ++o : --o) {
          results.push(this.column1(B, spriteB, i));
        }
        return results;
      }

      bPosP(B, pt) {
        return [Math.floor((pt[0] - B.boardX) / B.tWidth), Math.floor((pt[1] - B.boardY) / B.tHeight)];
      }

      sprPosP(B, pt) {
        return [pt[0] * B.tWidth + B.boardX, pt[1] * B.tHeight + B.boardY];
      }

      bPos1(B, x, y) {
        return [Math.floor((x - B.boardX) / B.tWidth), Math.floor((y - B.boardY) / B.tHeight)];
      }

      sprPos(B, x, y) {
        return [x * B.tWidth + B.boardX, y * B.tHeight + B.boardY];
      }

      bPos(B, x, y, buf) {
        var bX, bY;
        bX = Math.floor((x - B.boardX) / 40);
        if (!((bX * 40 + B.boardX + 3 < x && x < bX * 40 + B.boardX + 34))) { //-B.boardX
          bX = -1;
        }
        //		bX = -1 if not -1 < bX < B.bWidth
        bY = Math.floor((y - B.boardY) / 40);
        if (!((bY * 40 + B.boardY + 3 < y && y < bY * 40 + B.boardY + 34))) { //-B.boardY
          bY = -1;
        }
        //		bY = -1 if not -1 < bY < B.bHeight
        return [bX, bY];
      }

      locktoB(B, spriteB) {
        var e, len, o;
//adjust sparse indexes to current sprite locations
        for (o = 0, len = spriteB.length; o < len; o++) {
          e = spriteB[o];
          //$('#out').text(JSON.stringify([(@sprPosP(B, @bPosP(B,e.pos)) for e in spriteB)]))
          e.pos = this.sprPosP(B, this.bPosP(B, e.pos));
        }
        return this.sparseLock(B, spriteB);
      }

      spritestoB(B, spriteB) {
        var e, len, o, results;
        results = [];
        for (o = 0, len = spriteB.length; o < len; o++) {
          e = spriteB[o];
          results.push(B.LUT[[e.pos[0], e.pos[1]]]);
        }
        return results;
      }

      sparseLock(B, spriteB) {
        var board, e, len, o;
        board = ((function() {
          var results;
          results = [];
          while (spriteB.length > 0) {
            results.push(spriteB.pop());
          }
          return results;
        })());
        for (o = 0, len = board.length; o < len; o++) {
          e = board[o];
          board[this.bPosP(B, e.pos)] = e;
        }
        return this.spriteQ[0] = board;
      }

      difference(B, spriteB) {
        var e, len, o, ref, results;
        ref = B.mask;
        results = [];
        for (o = 0, len = ref.length; o < len; o++) {
          e = ref[o];
          if (spriteB[i] != null) {
            results.push(e);
          }
        }
        return results;
      }

      //fillB: (B, spriteB) ->
      //pruneB: ()

        //--
      printQ(Q) {
        var e, k, results;
        results = [];
        for (k in Q) {
          e = Q[k];
          results.push([k, e.pos]);
        }
        return results;
      }

      mkBehavior(fn) {
        var s;
        s = new Sprite(null, [[0, 0], [0, 0]]);
        s.upEx = fn; //does this get the game global binding right?
        return s;
      }

    };

    Game.time = new Date();

    return Game;

  }).call(this);

  //--
  //	drawSprite: (spr,B) ->
  //		ctx.draw(spr.img,spr.x,spr.y,,,,) if spr.srcB?
  //		ctx.draw(spr.img,spr.x,spr.y) if not spr.srcB?

    //-----

    //velocity helps (constant?) thrust and collisions; accel may help falling
  //paths vs dx/dy
  //sheet vs frame array  (need fn to break up sheet)
  Sprite = class Sprite {
    constructor(img, path1) { //@update) ->
      this.img = img;
      this.path = path1;
      this.pos = this.path[0];
      this.v = [
        0,
        0 //accel as vel path? no. #v/a as integers?
      ];
      this.a = [
        0,
        0 //??
      ];
      this.marks = {};
      this.id = 0;
      this.delay = 0;
      this.frame = 0;
      this.frames = []; //frames in strip (not sheet)
      this.srcB = void 0;
      this.srcXY = [0, 0];
      this.update = function() {
        return this.pkux(); //path based kill default; leave this way for this slots project
      };
      this.upEx = () => {
        return false;
      };
      this.pkux = function() {
        return this.upEx();
      };
      //			if @path.length < 2 #is 1  #either default this, or offer as a built in option!! with easy pass in... aniUp, aniExUp
      //				@kill = true
      //				@upEx()
      this.intensity = 100;
      this.dIntensity = 0;
      this.kill = false;
      //physics for later, (mass, point force, momentum, friction, )
      this.collidable = false;
      this.clickable = false;
    }

  };

  //click: () ->
  //iter:() ->

    //need: board offsets, board Width/height, tile height/width, mask
  //	spacing??
  Board = class Board {
    constructor(boardX, boardY, bWidth, bHeight, tWidth, tHeight) {
      var e, i, j, k, o, ref, ref1, u;
      this.boardX = boardX;
      this.boardY = boardY;
      this.bWidth = bWidth;
      this.bHeight = bHeight;
      this.tWidth = tWidth;
      this.tHeight = tHeight;
      this.lut = [];
//reverse map back to board pnts
      for (j = o = 0, ref = this.bHeight - 1; (0 <= ref ? o <= ref : o >= ref); j = 0 <= ref ? ++o : --o) {
        for (i = u = 0, ref1 = this.bWidth - 1; (0 <= ref1 ? u <= ref1 : u >= ref1); i = 0 <= ref1 ? ++u : --u) {
          this.lut[[i, j]] = [i, j];
        }
      }
      this.luta = (function() {
        var ref2, results;
        ref2 = this.lut;
        //because maps are apparently hard to work with??
        results = [];
        for (k in ref2) {
          e = ref2[k];
          results.push(e);
        }
        return results;
      }).call(this);
      this.maska = []; //(e for k,e of @LUT when @maskarr[e[0]][e[1]] isnt 0)  #all [x,y]'s in mask
      this.allX = this.tWidth * this.bWidth + this.boardX;
      this.allY = this.tHeight * this.bHeight + this.boardY;
      this.data = {};
      this.setmask = function(arr) {
        var len, ref2, results, v;
        ref2 = this.luta;
        results = [];
        for (v = 0, len = ref2.length; v < len; v++) {
          e = ref2[v];
          if (!(arr[e[0]][e[1]] === 1)) {
            continue;
          }
          this.maska.push(e);
          results.push(this.maska[e] = e);
        }
        return results;
      };
    }

  };

  //			@maska = []
  //			for e in @luta
  //				@maska.push(e) if arr[e[0]][e[1]] is 1

  //			@maska = (e for e in @luta when arr[e[0]][e[1]] is 1)

  //			$('#out').text(JSON.stringify((e for k,e of @lut)))
  //			@mask = (e for k,e of @lut when arr[e[0]][e[1]] isnt 0)
  $(function() {
    var myGame;
    $("#out").text = "testing";
    return myGame = new Game();
  });

}).call(this);
